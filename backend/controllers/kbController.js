import { v4 as uuidv4 } from 'uuid';
import KBModel from '../models/kbModel.js';

const kbModel = new KBModel();

const getKBAnswer = async (req, res) => {
    console.log('body received:', req.body);

    const { message, user_id, conversation_id } = req.body;

    if (!message || !user_id || !conversation_id) {
        return res.status(400).json({ error: "Missing required fields: message, user_id, or conversation_id" });
    }

    const sessionId = `${user_id}-${conversation_id}`;
    const question = message;

    const chatHistory = await kbModel.getChatHistory(sessionId);
    const messages = await chatHistory.getMessages();

    messages.push(kbModel.getHumanMessage(question));

    console.log("initiating model response...");

    const modelResponse = await kbModel.invokeGraph(messages, sessionId);

    console.log("MODEL RESPONSE:", modelResponse);

    // The new routing logic returns state with route information
    // We need to find the final response message
    let finalResponseContent = '';
    let agentWorkflowSteps = [];
    let sourceDocuments = modelResponse.sourceDocuments || [];

    // Find the final AI message that contains the actual response
    // Look for the last AIMessage that has routerDecision information
    const routerMessages = modelResponse.messages.filter(msg => 
        msg.lc_type === 'AIMessage' && 
        typeof msg.content === 'string' && 
        msg.content.includes('routerDecision')
    );

    if (routerMessages.length > 0) {
        const lastRouterMessage = routerMessages[routerMessages.length - 1];
        try {
            const routerData = JSON.parse(lastRouterMessage.content);
            
            if (routerData.routerDecision === "WEB_SEARCH") {
                // For WEB_SEARCH, we need to look for the actual answer from retrieveAndAnswer
                const answerMessage = modelResponse.messages.find(msg => 
                    msg.lc_type === 'AIMessage' && 
                    typeof msg.content === 'string' && 
                    !msg.content.includes('routerDecision') &&
                    !msg.content.includes('{') &&
                    !msg.content.includes('}')
                );
                
                if (answerMessage) {
                    finalResponseContent = answerMessage.content;
                    agentWorkflowSteps = [{ "agent": "RouterAgent", "decision": "WebSearch" }, { "agent": "KnowledgeAgent" }];
                } else {
                    finalResponseContent = "Não foi possível encontrar uma resposta relevante.";
                    agentWorkflowSteps = [{ "agent": "RouterAgent", "decision": "WebSearch" }, { "agent": "System", "decision": "Error" }];
                }
            } else if (routerData.routerDecision === "ANSWER_DIRECTLY") {
                // For ANSWER_DIRECTLY, use the message from the router
                finalResponseContent = routerData.message;
                agentWorkflowSteps = [{ "agent": "RouterAgent", "decision": "AnswerDirectly" }];
            } else {
                finalResponseContent = "Erro ao processar a decisão do roteador.";
                agentWorkflowSteps = [{ "agent": "System", "decision": "Error" }];
            }
        } catch (error) {
            console.error("Error parsing router message:", error);
            finalResponseContent = "Erro ao processar a resposta do roteador.";
            agentWorkflowSteps = [{ "agent": "System", "decision": "Error" }];
        }
    } else {
        finalResponseContent = "Não foi possível processar a resposta do modelo.";
        agentWorkflowSteps = [{ "agent": "System", "decision": "Error" }];
    }

    await chatHistory.addMessage(kbModel.getHumanMessage(question));
    // Add the final response message to chat history
    await chatHistory.addMessage(kbModel.getAIMessage(finalResponseContent));

    res.json({
        response: finalResponseContent, // Main response with personality
        source_agent_response: finalResponseContent, // Text generated by the specialized agent
        agent_workflow: agentWorkflowSteps,
        sourceDocuments: sourceDocuments.map(doc => ({
            pageContent: doc.pageContent,
            metadata: doc.metadata.source
        }))
    });
};

export { getKBAnswer }; 