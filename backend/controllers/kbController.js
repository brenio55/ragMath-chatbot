import { v4 as uuidv4 } from 'uuid';
import KBModel from '../models/kbModel.js';

const kbModel = new KBModel();

const getKBAnswer = async (req, res) => {
    console.log('body received:', req.body);

    const { message, user_id, conversation_id } = req.body;

    if (!message || !user_id || !conversation_id) {
        return res.status(400).json({ error: "Missing required fields: message, user_id, or conversation_id" });
    }

    const sessionId = `${user_id}-${conversation_id}`;
    const question = message;

    const chatHistory = await kbModel.getChatHistory(sessionId);
    const messages = await chatHistory.getMessages();

    messages.push(kbModel.getHumanMessage(question));

    console.log("initiating model response...");

    const modelResponse = await kbModel.invokeGraph(messages, sessionId);

    console.log("MODEL RESPONSE:", modelResponse);
    console.log("Messages in response:", modelResponse.messages.map(msg => ({
        type: msg.constructor.name,
        content: typeof msg.content === 'string' ? msg.content.substring(0, 100) + '...' : msg.content
    })));

    // Process the model response to extract the final answer
    let finalResponseContent = '';
    let agentWorkflowSteps = [];
    let sourceDocuments = modelResponse.sourceDocuments || [];

    // Find the last AI message that contains the router decision
    const routerMessages = modelResponse.messages.filter(msg => 
        msg.constructor.name === 'AIMessage' && 
        typeof msg.content === 'string' && 
        msg.content.includes('routerDecision')
    );

    if (routerMessages.length > 0) {
        const lastRouterMessage = routerMessages[routerMessages.length - 1];
        try {
            const routerData = JSON.parse(lastRouterMessage.content);
            
            if (routerData.routerDecision === "WEB_SEARCH") {
                // For WEB_SEARCH, look for the actual answer from retrieveAndAnswer
                const answerMessages = modelResponse.messages.filter(msg => 
                    msg.constructor.name === 'AIMessage' && 
                    typeof msg.content === 'string' && 
                    !msg.content.includes('routerDecision')
                );
                
                // Get the last non-router message as the answer
                if (answerMessages.length > 0) {
                    const lastAnswerMessage = answerMessages[answerMessages.length - 1];
                    finalResponseContent = lastAnswerMessage.content;
                    agentWorkflowSteps = [{ "agent": "RouterAgent", "decision": "WebSearch" }, { "agent": "KnowledgeAgent" }];
                } else {
                    finalResponseContent = "Não foi possível encontrar uma resposta relevante.";
                    agentWorkflowSteps = [{ "agent": "RouterAgent", "decision": "WebSearch" }, { "agent": "System", "decision": "Error" }];
                }
            } else if (routerData.routerDecision === "ANSWER_DIRECTLY") {
                // For ANSWER_DIRECTLY, use the message from the router
                finalResponseContent = routerData.message;
                agentWorkflowSteps = [{ "agent": "RouterAgent", "decision": "AnswerDirectly" }];
            } else {
                finalResponseContent = "Erro ao processar a decisão do roteador.";
                agentWorkflowSteps = [{ "agent": "System", "decision": "Error" }];
            }
        } catch (error) {
            console.error("Error parsing router message:", error);
            finalResponseContent = "Erro ao processar a resposta do roteador.";
            agentWorkflowSteps = [{ "agent": "System", "decision": "Error" }];
        }
    } else {
        // Fallback: look for any AI message that doesn't contain routerDecision
        const nonRouterMessages = modelResponse.messages.filter(msg => 
            msg.constructor.name === 'AIMessage' && 
            typeof msg.content === 'string' && 
            !msg.content.includes('routerDecision')
        );
        
        if (nonRouterMessages.length > 0) {
            finalResponseContent = nonRouterMessages[nonRouterMessages.length - 1].content;
            agentWorkflowSteps = [{ "agent": "System", "decision": "DirectAnswer" }];
        } else {
            finalResponseContent = "Não foi possível processar a resposta do modelo.";
            agentWorkflowSteps = [{ "agent": "System", "decision": "Error" }];
        }
    }

    await chatHistory.addMessage(kbModel.getHumanMessage(question));
    // Add the final response message to chat history
    await chatHistory.addMessage(kbModel.getAIMessage(finalResponseContent));

    res.json({
        response: finalResponseContent, // Main response with personality
        source_agent_response: finalResponseContent, // Text generated by the specialized agent
        agent_workflow: agentWorkflowSteps,
        sourceDocuments: sourceDocuments.map(doc => ({
            pageContent: doc.pageContent,
            metadata: doc.metadata.source
        }))
    });
};

export { getKBAnswer }; 